# Лямбды

До `Java 8` мы жили так:

```java
Collections.sort(new Comparator<String>() {
    public int Compare() {
        //
    }
})
```

А в `Java 8` появились лямбды!

```java
Collections.sort(list, (a, b) -> b.compareTo(a));
```

Изначально это был просто синтаксический сахар уже в `Java 7`. Но это работало бесконечно долго, потому что каждый анонимный класс компилируется в отдельный файл. И уже в `Java 8` всё переписали.

## Интерфейсы

- В `Java 8` в интерфейсах разрешили писать реализации

- Разрешили писать `default` реализации, то есть если у класса нет реализации метода, то будет взята дефолтная реализация
    - Не доступно для `equals()`, `hashCode()`, `toString()`. Почему нельзя - обоснование ниже

```java
interface F {
    default equals()
}

class X implements F {
    // но тут не появится метод equals(), потому что есть неявное наследование от Object и возьмём метод оттуда
}
```

```java
interface Foo {
    default int f(int x) { return x + 42 }

}

interface Bar {
    default int f(int x) { return x * x }
    
}

class FooBar implements Foo, Bar { } // Fail, непонятно что вызывать. Надо явно указывать
// Но если у нас наследование и реализация интерфейса и там одинаковые методы - вызовем метод класса
```

## Функциональные интерфейсы

1. Интерфейсы, у которых ровно 1 абстрактный метод
1. Опционально можно добавить аннотация `@FunctionalInterface` - заставляем компилятор проверить, что является таковым

Примеры:
1. Компаратор
1. `Function<T, R>`
1. `BiFunction<T, U, R>`
1. `Consumer<T>`

## Лямбды

1. Новый компактный синтаксис для функциональных интерфейсов. Но ведёт себя так, как будто мы создали экземпляр анонимного класса. Хранятся вместе с классом, где их используем. Чтобы поддержать это - в `JVM` добавили `invoke dymanic`.
1. Компилятор сам выводит типы. Лямбды реализованы не как класс, а с помощью специальной bite-code инструкции: ссылки на лямбды складываются в один класс,
а далее везде, где они используются, происходит обращение к данному классу, чтобы получить ссылку на функцию (**lambda == реализация функционального интерфейса, не имеющего состояния**).

```java
class A {
   A foo(A) {...}
}
```
`A::foo` - не имеет типа, поэтому записи след. вида валидны:
```java
Function<A, A> func = A::foo;
UnaryOperator<A, A> op = A::foo;
```
Компилятор при подстановке выводит тип и проверяет его на валидность.

```java
List<User> users = getAllUSers()
Collections.sort(users, (u1, u2) -> 
    u1.getName().compareTo(u2.getName()));
```

## Применение лямбд

1. `list.forEach(u -> ...)` - принимает на вход `Consumer`. То есть над каждым объектом есть возможность совершить какое-то действие
1. `users.removeIf(u -> ...)`

То, что лямбды не являются анонимными классами - даёт нам право делать так:

```java
Function<String, Integer> f1 = Integer::parseInt
// ~ x -> Integer.parseInt()
```

У лямбды нет типа, он обретается тогда, когда мы её куда-то подставляем

Ограничения лямбд:

1. Не можем захватывать не `final` переменные
1. Не умеем бросать исключение
1. Лямбда - не класс

У лямбды нет никакого состояния, ровно 1 метод, нет секции инициализации.

## Основные интерфейсы

Функции
- `Function<T, R> :: T -> R`
- `Predicate<T> :: T -> boolean`
- `Supplier<T> :: () -> T`
- `Consumer<T> :: T -> void`

Операторы
- `UnaryOperator<T> :: T -> T`
- `BinaryOperator<T> :: T -> T -> T`

Удвоенные интерфейсы
- `BiFunction<T, U, R> :: T -> U -> R`
- `BiConsumer<T, U> :: T -> U > void`
- `BiPredicate<T, U> :: T -> U -> boolean`

## `java.util.collection`

Класс `Optional<T>` - контейнер на 1 элемент, который может быть пустой или не пустой.

Операции:
1. `get()` - то, что лежит или исключение
1. `isPresent()`

## Конструкторы компараторов

Методы интерфейса `Comparator`
- `comparing(f, cmp?)` - сравниваем `f(o)`, если передан `cmp` - то с помощью этого компаратора, иначе просто вызывается `o1.compareTo(o2)`
- `nullsFirst/nullLast(cmp)` - порядок для `null`
- `cmp.thenComparing(f, cmp?)` - лексикографический порядок

```java
students.sort(Comparator.comparingInt(Students::getAge) // comparing* - специализации для примитивных типов
                thenComparing(
                    Student::getName, 
                    String.CASE_SENSETIVE_ORDER
));
```

## `java.util.stream`

```java
collection.stream()
    .filter(s -> s.endsWith("s"))
    .mapToInt(String::length)
    .max()

parallelStream() // обрабатывается на разных ядрах, чтобы это реализовать существует splitIterator
```

Работает, начиная с конца, сначала вызывается `max()`, он просит у прошлой команды в цепочке один элемент и так далее. Потом `max()` доставляют элемент и он просит новый. 

Это классы `Stream, IntStream, ...`. `IntStream` - стрим для примитивных типов

Это поток элементов, обрабатываемый оптом
- Может не хранить элементы
- Может быть ленивым
- Может быть бесконечным

Операции над потоками:
1. Промежуточные(конвейерные)
    - Порождают поток
    - Ленивые

1. Терминальные(завершающие)
    - Порождают значения
    - Жадные

Как отличить терминальную операцию от промежуточной? Промежуточные возвращают `Stream`, а терминальные - что-то другое (или ничего)

Терминальная операция выковыривает из стрима данные, если её нет - не будет сделано вообще ни одного действия

## Способы создания стримов

1. Создание стрима из коллекции
```java
Stream<String> streamFromCollection = collection.stream();
```
2. Создание стрима из значений
```java
Stream<String> streamFromValue = Stream.of("a1", "a2", "a3");
```
3. Создание стрима из массива
```java
Stream<String> streamFromArrays = Arrays.stream(array);
```
4. Создание стрима из файла
```java
Stream<String> streamFromFiles = Files.lines(Paths.get("file.txt"));
```
5. Создание стрима из строки
```java
Stream<String> streamFromString = "123".chars();
```
6. Создание стрима из значений
```java
IntStream streamFromValue = Stream.of("a1", "a2", "a3");
```
7. Создание с помощью Stream.builder
8. Создание параллельного стрима
9. Создание бесконечного стрима с помощью `Stream.iterate`
```java
Stream<Integer> streamFromIterate = Stream.iterate(1, n -> n + 1); // тут нужна Function и начальное значение
```
1. Создание бесконечного стрима с помощью `Stream.generate`
```java
Stream<String> streamFromGenerate = Stream.generate(() -> "a1"); // тут на вход Supplier
```


## Конвейерные операции

1. `filter` - отфильтровывает записи по предикату
1. `skip` - позволяет пропустить первые `n` элементов
1. `distinct` - возвращает стрим без дубликатов (проверка на равенство с помощью `equals`)
1. `map` - преобразует каждый элемент стрима, меняет тип стрима
1. `peek` - возвращает тот же стрим, но принименяет функцию к элементу стрима (не путать с `forEach`!)
1. `limit` - позволяет ограничить выборку определённым количеством первых элементов
1. `sorted` - позволяет сортироваться либо в натуральном порядке, либо задавая `Comparator`
1. `mapToInt`, `mapToLong`, `mapToLong` - аналоги `map`, но возвращают числовой стрим
1. `flatMap` и компания для примитивных. Принимает также на вход функцию, результатом работы которой является `Stream` и объединяет получившиеся потоки в один

## Терминальные операции

1. `findFirst` - возвращает первый элемент из стрима (возвращает `Optional`)
1. `findAny` - возвращает любой подходящий элемент
1. `collect` - представление результатов в виде коллекций и других структур данных
1. `count` - количество элементов в стриме
1. `anyMatch` - возвращает `true`, если условие выполняется хотя бы для 1 элемента
1. `noneMatch` - как предыдущее, но `true`, если не выполняется ни для какого
1. `allMatch` - условие выполняется для всех
1. `min` - возвращает минимальный элемент, в качестве условия использует компаратор
1. `max` - возвращает максимальный, использует компаратор
1. `forEach` - применяет функцию к каждому объекту, порядок при параллельном выполнении не гарантируется
1. `forEachOrdered` - как предыдущее, но порядок гарантируется
1. `toArray` - возвращает массив значений стрима

Дальше идет куча примеров, можно посмотреть в презентации

Что важно: условный `filter` не обязательно должен принимать на вход какую-то лямбду или ссылку на метод. Мы также можем создать там и анонимный класс. В чём идея - у него может быть какое-то состояние
